__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1766191753012, "solver": [".py", "\n\n\n\n\"\"\"Module providing the Execubot class and its convenient functions.\"\"\"\n\nimport os\nimport sys\nimport time\n\n\nGrid=list[list[str]]|list[str]\n\n\ndef timer(f):\n ''\n def wrapper(self,*args,**kwargs):\n  if time.time()-self.start >self.timeout:\n   raise TimeoutError\n  return f(self,*args,**kwargs)\n return wrapper\n \n \nclass Execubot:\n ''\n colors={'p':\"purple\",'y':\"yellow\",'g':\"green\",'b':\"blue\",'r':\"red\",\n 'o':\"orange\",'m':\"maroon\",'w':\"white\",'f':\"fuchsia\"}\n directions={\"left\":(-1,0),\"right\":(1,0),\"up\":(0,-1),\"down\":(0,1)}\n translations={\n \"en\":{color:color for color in colors.values()}\n |{direction:direction for direction in directions},\n \"fr\":{\"purple\":\"violet\",\"yellow\":\"jaune\",\"green\":\"vert\",\"blue\":\"bleu\",\"red\":\"rouge\",\n \"orange\":\"orange\",\"maroon\":\"marron\",\"white\":\"blanc\",\"fuchsia\":\"rose\",\n \"left\":\"gauche\",\"right\":\"droite\",\"up\":\"haut\",\"down\":\"bas\"},\n \"es\":{\"purple\":\"p\u00farpura\",\"yellow\":\"amarillo\",\"green\":\"verde\",\"blue\":\"azul\",\"red\":\"rojo\",\n \"orange\":\"naranja\",\"maroon\":\"marr\u00f3n\",\"white\":\"blanco\",\"fuchsia\":\"rosa\",\n \"left\":\"izquierda\",\"right\":\"derecha\",\"up\":\"arriba\",\"down\":\"abajo\"},\n \"vi\":{\"purple\":\"t\u00edm\",\"yellow\":\"v\u00e0ng\",\"green\":\"xanh l\u00e1\",\"blue\":\"xanh d\u01b0\u01a1ng\",\"red\":\"\u0111\u1ecf\",\n \"orange\":\"cam\",\"maroon\":\"n\u00e2u\",\"white\":\"tr\u1eafng\",\"fuchsia\":\"h\u1ed3ng\",\n \"left\":\"tr\u00e1i\",\"right\":\"ph\u1ea3i\",\"up\":\"l\u00ean\",\"down\":\"xu\u1ed1ng\"},\n }\n timeout=1\n \n def __init__(self,code:str,grid:Grid,row:int,col:int,lang:str):\n  self.code=code\n  self.grid=self.stdgrid(grid)\n  self.tr=self.translations[lang]\n  self.coord=(col,row)\n  self.size=(len(self.grid[0]),len(self.grid))\n  self.solution=[]\n  self.start=0.0\n  \n @classmethod\n def stdgrid(cls,grid:Grid)->list[list[str]]:\n  ''\n  if isinstance(grid[0],str):\n   return[['-'.join([cls.colors[clr]for clr in clrs])for clrs in line.split()]for line in grid]\n  return grid\n  \n @staticmethod\n def lindex()->int:\n  ''\n  return sys._getframe(4).f_lineno -1\n  \n @timer\n def color(self,color:str)->bool:\n  ''\n  x,y=self.coord\n  return color in self.grid[y][x]\n  \n @timer\n def direction(self,direction:str)->None:\n  ''\n  self.solution.append((direction.capitalize(),self.lindex()))\n  dx,dy=self.directions[direction]\n  x,y=self.coord\n  w,h=self.size\n  self.coord=((x+dx)%w,(y+dy)%h)\n  \n def solver(self)->list[tuple[str,int]]:\n  ''\n  colorsd={self.tr[color].replace(\" \",\"_\"):lambda c=color,t=self.tr[color]:\n  self.color(c)or self.color(t)for color in self.colors.values()}\n  directionsd={self.tr[direction]:lambda d=direction:\n  self.direction(d)for direction in self.directions}\n  self.start=time.time()\n  exec(self.code,colorsd |directionsd)\n  return self.solution\n  \n @classmethod\n def extractor(cls,level:str,legacy:bool)->dict[str,Grid |str |int]:\n  ''\n  if os.path.isfile(level)and os.path.splitext(level)[1]=='.py':\n   with open(level,encoding=\"utf-8\")as f:\n    code_py=f.readlines()\n  else:\n   code_py=level.splitlines(keepends=True)\n  lcode=len(code_py)\n  i=0\n  while i <lcode and code_py[i].strip():\n   i=i+1\n  if i ==lcode:\n   raise ExecubotLevelFormatError(\"A blank line between the header and the Python code is required.\")\n  d={}\n  level_id=os.path.splitext(os.path.basename(level))[0][5:]\n  if level_id.isdigit():\n   d[\"level_id\"]=int(level_id)\n  d[\"code\"]=''.join(code_py[i+1:])\n  exec(''.join(code_py[:i]),{},d)\n  if \"grid\"not in d:\n   raise ExecubotLevelFormatError(\"A grid variable is required.\")\n  if legacy:\n   d={k:v for k,v in d.items()if k in cls.__init__.__code__.co_varnames}\n  return d\n  \n  \nclass ExecubotLevelFormatError(Exception):\n ''\n \n \ndef stdgrid(grid:Grid)->list[list[str]]:\n ''\n return Execubot.stdgrid(grid)\n \n \ndef extractor(level:str,legacy:bool=False)->dict[str,Grid |str |int]:\n ''\n return Execubot.extractor(level,legacy)\n \n \ndef solver(code:str,grid:Grid,row:int=0,col:int=0,lang:str='en')->list[tuple[str,int]]:\n ''\n return Execubot(code,grid,row,col,lang).solver()\n \n \ndef solve(level:str)->list[tuple[str,int]]:\n ''\n return solver(**extractor(level,True))\n", ["os", "sys", "time"]]}
__BRYTHON__.update_VFS(scripts)
