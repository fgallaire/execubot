__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1771547373097, "solver": [".py", "\n\n\n\n\"\"\"Module providing the Execubot class and its convenient functions.\"\"\"\n\nimport os\nimport sys\nimport time\ntry:\n from.translation import T\nexcept ImportError:\n if sys.platform ==\"brython\":\n  import json\n  with open(\"json/solver.json\")as f:\n   T=json.load(f)\n else:\n  T={}\n  \n  \nGrid=list[list[str]]|list[str]\n\nLang=dict[str,str]|str\n\n\ndef timer(timeout:int):\n ''\n def decorator(f):\n  def wrapper(self,*args,**kwargs):\n   if time.time()-self.start >timeout:\n    raise TimeoutError\n   return f(self,*args,**kwargs)\n  return wrapper\n return decorator\n \n \nclass Execubot:\n ''\n colors={'p':\"purple\",'y':\"yellow\",'g':\"green\",'b':\"blue\",'r':\"red\",\n 'o':\"orange\",'m':\"maroon\",'w':\"white\",'f':\"fuchsia\"}\n directions={\"left\":(-1,0),\"right\":(1,0),\"up\":(0,-1),\"down\":(0,1)}\n translations={\"en\":{color:color for color in colors.values()}\n |{direction:direction for direction in directions}}|T\n timeout=1\n \n def __init__(self,code:str,grid:Grid,row:int,col:int,lang:Lang):\n  self.code=code\n  self.grid=self.stdgrid(grid)\n  self.tr=self.dictlang(lang)\n  self.coord=(col,row)\n  self.size=(len(self.grid[0]),len(self.grid))\n  self.solution=[]\n  self.start=0.0\n  \n @classmethod\n def stdgrid(cls,grid:Grid)->list[list[str]]:\n  ''\n  if isinstance(grid[0],str):\n   return[['-'.join([cls.colors[clr]for clr in clrs])for clrs in line.split()]for line in grid]\n  return grid\n  \n @classmethod\n def dictlang(cls,lang:Lang)->dict[str,str]:\n  ''\n  if isinstance(lang,str):\n   return cls.translations[lang]\n  return lang\n  \n @staticmethod\n def lindex()->int:\n  ''\n  return sys._getframe(4).f_lineno -1\n  \n @timer(timeout)\n def color(self,color:str)->bool:\n  ''\n  x,y=self.coord\n  return color in self.grid[y][x]\n  \n @timer(timeout)\n def direction(self,direction:str)->None:\n  ''\n  self.solution.append((direction.capitalize(),self.lindex()))\n  dx,dy=self.directions[direction]\n  x,y=self.coord\n  w,h=self.size\n  self.coord=((x+dx)%w,(y+dy)%h)\n  \n def solver(self)->list[tuple[str,int]]:\n  ''\n  colorsd={self.tr[color].replace(\" \",\"_\"):lambda c=color,t=self.tr[color]:\n  self.color(c)or self.color(t)for color in self.colors.values()}\n  directionsd={self.tr[direction]:lambda d=direction:\n  self.direction(d)for direction in self.directions}\n  self.start=time.time()\n  exec(self.code,colorsd |directionsd)\n  return self.solution\n  \n @classmethod\n def extractor(cls,level:str,legacy:bool)->dict[str,Grid |Lang |str |int]:\n  ''\n  if os.path.isfile(level):\n   with open(level,encoding=\"utf-8\")as f:\n    code_py=f.readlines()\n  else:\n   code_py=level.splitlines(keepends=True)\n  lcode=len(code_py)\n  i=0\n  while i <lcode and code_py[i].strip():\n   i=i+1\n  if i ==lcode:\n   raise ExecubotLevelFormatError(\"A blank line between the header and the Python code is required.\")\n  d={}\n  level_id=os.path.splitext(os.path.basename(level))[0][5:]\n  if level_id.isdigit():\n   d[\"level_id\"]=int(level_id)\n  d[\"code\"]=''.join(code_py[i+1:])\n  exec(''.join(code_py[:i]),{},d)\n  if \"grid\"not in d:\n   raise ExecubotLevelFormatError(\"A grid variable is required.\")\n  if legacy:\n   d={k:v for k,v in d.items()if k in cls.__init__.__code__.co_varnames}\n  return d\n  \n  \nclass ExecubotLevelFormatError(Exception):\n ''\n \n \ndef stdgrid(grid:Grid)->list[list[str]]:\n ''\n return Execubot.stdgrid(grid)\n \n \ndef dictlang(lang:Lang)->dict[str,str]:\n ''\n return Execubot.dictlang(lang)\n \n \ndef extractor(level:str,legacy:bool=False)->dict[str,Grid |Lang |str |int]:\n ''\n return Execubot.extractor(level,legacy)\n \n \ndef solver(code:str,grid:Grid,row:int=0,col:int=0,lang:str='en')->list[tuple[str,int]]:\n ''\n return Execubot(code,grid,row,col,lang).solver()\n \n \ndef solve(level:str)->list[tuple[str,int]]:\n ''\n return solver(**extractor(level,True))\n", [".translation", "json", "os", "sys", "time"]]}
__BRYTHON__.update_VFS(scripts)
__BRYTHON__.runPythonSource("import solver")
solve = __BRYTHON__.getPythonModule("solver").solve
extractor = __BRYTHON__.getPythonModule("solver").extractor
stdgrid = __BRYTHON__.getPythonModule("solver").stdgrid
