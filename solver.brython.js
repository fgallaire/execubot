__BRYTHON__.use_VFS = true;
var scripts = {"$timestamp": 1754675559638, "solver": [".py", "\n\n\n\n\"\"\"Module providing the Execubot class and its convenient functions.\"\"\"\n\nimport os\nimport sys\nimport time\n\n\nGrid=list[list[str]]|list[str]\n\n\ndef timer(f):\n ''\n def wrapper(self,*args):\n  if time.time()-self.start >self.timeout:\n   raise TimeoutError\n  return f(self,*args)\n return wrapper\n \n \nclass Execubot:\n ''\n colors={'p':\"purple\",'y':\"yellow\",'g':\"green\",'b':\"blue\",'r':\"red\",\n 'o':\"orange\",'m':\"maroon\",'w':\"white\",'f':\"fuchsia\"}\n directions={\"left\":(-1,0),\"right\":(1,0),\"up\":(0,-1),\"down\":(0,1)}\n timeout=1\n \n def __init__(self,code:str,grid:Grid,row:int,col:int):\n  self.code=code\n  self.grid=self.stdgrid(grid)\n  self.row=row\n  self.col=col\n  self.coord=(col,row)\n  self.size=(len(self.grid[0]),len(self.grid))\n  self.solution=[]\n  self.start=0.0\n  \n @classmethod\n def stdgrid(cls,grid:Grid)->list[list[str]]:\n  ''\n  if isinstance(grid[0],str):\n   return[['-'.join([cls.colors[clr]for clr in clrs])for clrs in line.split()]for line in grid]\n  return grid\n  \n @staticmethod\n def lindex()->int:\n  ''\n  return sys._getframe(4).f_lineno -1\n  \n @timer\n def color(self,color:str)->bool:\n  ''\n  x,y=self.coord\n  return color in self.grid[y][x]\n  \n @timer\n def direction(self,direction:str):\n  ''\n  self.solution.append((direction.capitalize(),self.lindex()))\n  dx,dy=self.directions[direction]\n  x,y=self.coord\n  w,h=self.size\n  self.coord=((x+dx)%w,(y+dy)%h)\n  \n def solver(self)->list[tuple[str,int]]:\n  ''\n  colorsd={color:lambda c=color:self.color(c)for color in self.colors.values()}\n  directionsd={direction:lambda d=direction:self.direction(d)for direction in self.directions}\n  self.start=time.time()\n  exec(self.code,colorsd |directionsd)\n  return self.solution\n  \n @classmethod\n def extractor(cls,level:str,legacy:bool)->dict[str,Grid |str |int]:\n  ''\n  if os.path.isfile(level)and os.path.splitext(level)[1]=='.py':\n   with open(level,encoding=\"utf-8\")as f:\n    code_py=f.readlines()\n  else:\n   code_py=level.splitlines(keepends=True)\n  lcode=len(code_py)\n  i=0\n  while i <lcode and code_py[i].strip():\n   i=i+1\n  if i ==lcode:\n   raise ExecubotLevelFormatError(\"A blank line between the header and the Python code is required.\")\n  d={}\n  level_id=os.path.splitext(os.path.basename(level))[0][5:]\n  if level_id.isdigit():\n   d[\"level_id\"]=int(level_id)\n  d[\"code\"]=''.join(code_py[i+1:])\n  exec(''.join(code_py[:i]),{},d)\n  if \"grid\"not in d:\n   raise ExecubotLevelFormatError(\"A grid variable is required.\")\n  if legacy:\n   d={k:v for k,v in d.items()if k in cls.__init__.__code__.co_varnames}\n  return d\n  \n  \nclass ExecubotLevelFormatError(Exception):\n ''\n \n \ndef stdgrid(grid:Grid)->list[list[str]]:\n ''\n return Execubot.stdgrid(grid)\n \n \ndef extractor(level:str,legacy:bool=False)->dict[str,Grid |str |int]:\n ''\n return Execubot.extractor(level,legacy)\n \n \ndef solver(code:str,grid:Grid,row:int=0,col:int=0)->list[tuple[str,int]]:\n ''\n return Execubot(code,grid,row,col).solver()\n \n \ndef solve(level:str)->list[tuple[str,int]]:\n ''\n return solver(**extractor(level,True))\n", ["os", "sys", "time"]]}
__BRYTHON__.update_VFS(scripts)
__BRYTHON__.curdir = "https://execubot.fr"
__BRYTHON__.runPythonSource("import solver")
solve = __BRYTHON__.getPythonModule("solver").solve
solver = __BRYTHON__.getPythonModule("solver").solver
